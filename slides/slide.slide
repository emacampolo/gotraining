Go workshop

* Types

* Type provides us two pieces of information: size and representation

    // float tells us it's an IEEE 754 binary decimal
    // 64 tells us that it's an eight byte value

    var f float64

    // we know it is an integer but size will depend on the architecture 64 bits (8 bytes) or 32 bits (4 bytes)

    var i int

    // we explicitly declare its size. We should have a very good reason to do so.

    var j int64

* Variable declaration and implicit initialization

.play -edit variable/variable.go /START OMIT/,/END OMIT/

* Variable declaration and explicit initialization

    bb := "hello"
    cc := 3.14159
    dd := true
    zz := 1

* var is a readability marker

    x := 0
    var x int // preferable

    s := ""
    var s string // preferable

    var i int = 10 // we should avoid this construction

_just_be_consistent_

* Struct types

* Struct types

    // example represents a type with different fields.
    type example struct {
    	flag    bool
    	counter int16
    	pi      float32
    }

    // Declare a variable of type example set to its zero value.
    var e1 example

    // Declare a variable of type example and init using
    // a struct literal.
    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    // We may see empty literal constructions when initializing to its zero value but we prefer var.
    // The only time when you see this idiom is when returning from a function for example.
    // Just be consistent.
    //e2 := example{}

* Struct types

    func main() {
        // Declare a variable of an *anonymous* type set to its zero value.
        var e1 struct {
            flag    bool
            counter int16
            pi      float32
        }

        // Declare a variable of an anonymous type and init
        // using a struct literal. Common usage in test tables.
        e2 := struct {
            flag    bool
            counter int16
            pi      float32
        }{
            flag:    true,
            counter: 10,
            pi:      3.141592,
        }
    }

* Struct types
    func main() {
        http.HandleFunc("/", handler(user.NewService()))
        log.Fatal(http.ListenAndServe(":8080", nil))
    }

    func handler(s *user.Service) http.HandlerFunc {
        type request struct {
            Name string
        }
        type response struct {
            Greeting string `json:"greeting"`
        }
        return func(w http.ResponseWriter, r *http.Request) {
            var input request
            read(r, &input)

            greeting := s.Execute(input.Name)
            resp := response{
                Greeting: greeting,
            }

            write(w, resp)
        }
    }

* Value semantics

- Everything in GO is pass by *value*
- There's two types of data that we operate with. It is the *value* *itself*, like the integer value 10, or it's the *value's* *address*
- Value semantics are a really important part of your ability to keep the heap clean
- *Pros*: Isolation, immutability, no side effect.
- *Cons*: multiple copies

* Value semantics

.play -edit value/semantics/semantics.go /START OMIT/,/END OMIT/

* Pointer semantics

- Everything in GO is pass by *value* (addresses too!)
- Pointers are for sharing
- We no longer acts in a sandbox
- Fixes the perf issue of value semantics at cost of allocation == GC
- Always ask yourself which semantics are in play!

* Pointer semantics

.play -edit pointer/semantics/semantics.go /START OMIT/,/END OMIT/

* Value semantics

.play -edit value/factory/factory.go

* Pointer semantics

.play -edit pointer/factory/factory.go

* Escape Analysis

- When a value could be referenced after the function that constructs the value returns
- When the compiler determines a value is too large to fit on the stack
- When the compiler doesn't know the size of a value at compile time
- When a value is decoupled through the use of function or interface values

* Semantics guidelines

Types:

- Built-in types: numerics, strings, bool
- Reference types: slices, maps, channels, interfaces values and functions
- User defined types

For 1 & 2 we should always use value semantics
Strings are designed to be copied

_Exception_: You may take the address of a slice or a map only if you're sharing it down the call-stack and to a function that's either named decode or un-marshall.

_Bottom_line_: When in doubt, use value semantics

* Arrays

* Arrays - Value semantics

.play -edit value/array/array.go

* Arrays - Pointer semantics

.play -edit pointer/array/array.go

* Slices - Value semantics

.play -edit value/slices/slices.go

* Slices - Pointer semantics

.play -edit pointer/slices/slices.go

* Methods & Functions

* Methods & Functions

.play -edit methods/example1/example.go /START OMIT/,/END OMIT/

* Methods & Functions

.play -edit methods/example2/example.go /START OMIT/,/END OMIT/

* Mixing semantics - The Horror

.play -edit mixing/mixing.go /START OMIT/,/END OMIT/

* Methods & Functions

.code time.go

* Correctness vs performance

We should first strive to optimize for correctness.
The lack of performance of your software is gonna come from four places

- Latency ⇒ networking and IO
- Data access ⇒ how you access data, how efficiently you access data.
- Memory allocations and therefore garbage collection
- Algorithm efficiencies ⇒ number of steps

: The hardware is so fast that we should focus on the first 3 problems instead of micro optimizing an algorithm.
: Correctness first.

* New Relic

.image only-go.png _ 1000

* "Once we start talking about milliseconds of latency, no optimization matters"  B.Kennedy

*

.image full.png _ 1000